<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scratcher Sim - Camera Follow</title>
    <style>
        :root { --primary: #2196F3; --accent: #4CAF50; --danger: #f44336; --dark: #1a1a1a; }
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Segoe UI', sans-serif; touch-action: none; 
            display: flex; flex-direction: column; height: 100dvh; 
        }
        canvas { flex: 1; display: block; background: #1a1a1a; cursor: crosshair; }
        #top-bar { height: 50px; background: #000; display: flex; justify-content: space-around; align-items: center; color: white; border-bottom: 2px solid #333; z-index: 10; }
        #bottom-bar { height: 80px; background: #000; display: flex; justify-content: center; align-items: center; padding-bottom: env(safe-area-inset-bottom); z-index: 10; }
        #build-confirm { display: none; position: absolute; gap: 10px; z-index: 100; }
        button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; color: white; }
        .btn-main { background: var(--primary); }
        .btn-action { background: var(--accent); padding: 15px 40px; font-size: 1.2rem; }
    </style>
</head>
<body>

<div id="top-bar">
    <div id="money-display">Cash: $100</div>
    <button class="btn-main" onclick="toggleBuildMode()">Build Mode</button>
</div>

<canvas id="gameCanvas"></canvas>

<div id="build-confirm">
    <button style="background:var(--accent)" onclick="confirmPlacement()">Confirm</button>
    <button style="background:var(--danger)" onclick="cancelPlacement()">Cancel</button>
</div>

<div id="bottom-bar">
    <button class="btn-action" onclick="triggerAction()">ACTION</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Grid & Camera Config
    let TILE = 60; 
    const COLS = 12, ROWS = 20; // 20 Rows ensures we have to scroll down
    const camera = { x: 0, y: 0 };

    let gameState = {
        money: 100,
        mode: 'PLAY',
        movingObj: null,
        isPlaced: false,
        tempPos: { gX: 0, gY: 0 },
        player: { x: 300, y: 300, tX: 300, tY: 300, holding: 0 },
        counter: { gridX: 5, gridY: 2, w: 1, h: 3, color: '#8d6e63' },
        shelves: [{ id: 1, gridX: 3, gridY: 8, w: 2, h: 1, color: '#5d4037' }],
        deliveries: []
    };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 130;
        TILE = window.innerWidth < 600 ? Math.floor(window.innerWidth / 8) : 60;
    }

    function toggleBuildMode() {
        gameState.mode = gameState.mode === 'PLAY' ? 'BUILD' : 'PLAY';
        gameState.movingObj = null;
        gameState.isPlaced = false;
        document.getElementById('build-confirm').style.display = 'none';
    }

    function triggerAction() {
        const p = gameState.player;
        if (p.holding > 0) {
            gameState.deliveries.push({ x: p.x, y: p.y, qty: p.holding });
            p.holding = 0;
        } else {
            gameState.deliveries.forEach((d, i) => {
                if (Math.hypot(p.x - d.x, p.y - d.y) < 60) {
                    p.holding = 5;
                    gameState.deliveries.splice(i, 1);
                }
            });
        }
    }

    function confirmPlacement() {
        if (gameState.movingObj) {
            gameState.movingObj.gridX = gameState.tempPos.gX;
            gameState.movingObj.gridY = gameState.tempPos.gY;
        }
        gameState.movingObj = null;
        gameState.isPlaced = false;
        document.getElementById('build-confirm').style.display = 'none';
    }

    function cancelPlacement() {
        gameState.movingObj = null;
        gameState.isPlaced = false;
        document.getElementById('build-confirm').style.display = 'none';
    }

    function update() {
        const p = gameState.player;
        p.x += (p.tX - p.x) * 0.12;
        p.y += (p.tY - p.y) * 0.12;

        // CAMERA CLAMPING (Reveals bottom part of the room)
        let targetX = p.x - canvas.width / 2;
        let targetY = p.y - canvas.height / 2;

        const worldW = COLS * TILE;
        const worldH = ROWS * TILE;

        // Stop camera from showing outside the shop boundaries
        camera.x = Math.max(0, Math.min(targetX, worldW - canvas.width));
        camera.y = Math.max(0, Math.min(targetY, worldH - canvas.height));
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Shop Floor (Starts at 0,0 World Space)
        ctx.fillStyle = "#222";
        ctx.fillRect(0, 0, COLS * TILE, ROWS * TILE);

        // Grid Lines
        ctx.strokeStyle = "#333";
        for(let i=0; i<=COLS; i++) {
            ctx.beginPath(); ctx.moveTo(i*TILE, 0); ctx.lineTo(i*TILE, ROWS*TILE); ctx.stroke();
        }
        for(let j=0; j<=ROWS; j++) {
            ctx.beginPath(); ctx.moveTo(0, j*TILE); ctx.lineTo(COLS*TILE, j*TILE); ctx.stroke();
        }

        // Counter
        const c = gameState.counter;
        ctx.fillStyle = c.color;
        ctx.fillRect(c.gridX * TILE, c.gridY * TILE, c.w * TILE, c.h * TILE);

        // Shelves
        gameState.shelves.forEach(s => {
            ctx.fillStyle = s.color;
            ctx.fillRect(s.gridX * TILE, s.gridY * TILE, s.w * TILE, s.h * TILE);
        });

        // Player
        ctx.fillStyle = "#2196F3";
        ctx.beginPath(); ctx.arc(gameState.player.x, gameState.player.y, 20, 0, Math.PI*2); ctx.fill();

        ctx.restore();
        
        document.getElementById('money-display').innerText = `Cash: $${gameState.money}`;
    }

    function handleInput(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        
        // CONVERT SCREEN CLICK TO WORLD SPACE
        const worldX = (clientX - rect.left) + camera.x;
        const worldY = (clientY - rect.top) + camera.y;
        
        const gX = Math.floor(worldX / TILE);
        const gY = Math.floor(worldY / TILE);

        if (gameState.mode === 'BUILD') {
            if (!gameState.movingObj) {
                // Selection logic must happen in World Space
                if (gX >= gameState.counter.gridX && gX < gameState.counter.gridX + gameState.counter.w &&
                    gY >= gameState.counter.gridY && gY < gameState.counter.gridY + gameState.counter.h) {
                    gameState.movingObj = gameState.counter;
                    return;
                }
                for (let s of gameState.shelves) {
                    if (gX >= s.gridX && gX < s.gridX + s.w && gY >= s.gridY && gY < s.gridY + s.h) {
                        gameState.movingObj = s;
                        return;
                    }
                }
            } else if (!gameState.isPlaced) {
                gameState.tempPos = { gX, gY };
                gameState.isPlaced = true;
                const ui = document.getElementById('build-confirm');
                ui.style.display = 'flex';
                ui.style.left = clientX + 'px';
                ui.style.top = (clientY - 60) + 'px';
                return;
            }
        }
        
        gameState.player.tX = worldX;
        gameState.player.tY = worldY;
    }

    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0) handleInput(e.clientX, e.clientY);
        if (e.button === 2) triggerAction();
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleInput(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    window.addEventListener('resize', resize);
    window.oncontextmenu = (e) => e.preventDefault();

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resize();
    loop();
</script>
</body>
</html>
