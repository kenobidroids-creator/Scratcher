<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scratcher Sim - Stable</title>
    <style>
        :root { --primary: #2196F3; --accent: #4CAF50; --danger: #f44336; }
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; touch-action: none; display: flex; flex-direction: column; height: 100vh; }
        canvas { flex: 1; display: block; background: #1a1a1a; }
        #top-bar { height: 50px; background: #000; display: flex; justify-content: space-around; align-items: center; color: white; border-bottom: 2px solid #333; }
        #bottom-bar { height: 80px; background: #000; display: flex; justify-content: center; align-items: center; padding-bottom: env(safe-area-inset-bottom); }
        #build-confirm { display: none; position: absolute; gap: 10px; z-index: 100; }
        button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; color: white; }
        .btn-main { background: var(--primary); }
        .btn-action { background: var(--accent); padding: 15px 40px; font-size: 1.2rem; }
    </style>
</head>
<body>

<div id="top-bar">
    <div id="money-display">Cash: $100</div>
    <button class="btn-main" onclick="toggleBuildMode()">Build Mode</button>
</div>

<canvas id="gameCanvas"></canvas>

<div id="build-confirm">
    <button style="background:var(--accent)" onclick="confirmPlacement()">Confirm</button>
    <button style="background:var(--danger)" onclick="cancelPlacement()">Cancel</button>
</div>

<div id="bottom-bar">
    <button class="btn-action" onclick="triggerAction()">ACTION</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // 1. GLOBAL VARIABLES (Using 'let' so resize works)
    let TILE = 50; 
    const COLS = 10, ROWS = 10;
    let offX = 0, offY = 0;

    let gameState = {
        money: 100,
        mode: 'PLAY',
        movingObj: null,
        isPlaced: false,
        tempPos: { gX: 0, gY: 0 },
        player: { x: 0, y: 0, tX: 0, tY: 0, holding: 0 },
        // MOVED HIGHER: gridY is now 1 and 2 instead of 7/8
        counter: { gridX: 4, gridY: 1, w: 2, h: 1, color: '#8d6e63' },
        shelves: [{ id: 1, gridX: 2, gridY: 3, w: 2, h: 1, color: '#5d4037' }],
        deliveries: []
    };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 130;
        
        // Dynamic tile size that fits the screen width
        TILE = Math.floor(canvas.width / (COLS + 2));
        
        offX = (canvas.width - (COLS * TILE)) / 2;
        // Keep the shop near the top so it's reachable
        offY = 40; 

        // Initial player placement
        if (gameState.player.x === 0) {
            gameState.player.x = offX + 5 * TILE;
            gameState.player.y = offY + 8 * TILE;
            gameState.player.tX = gameState.player.x;
            gameState.player.tY = gameState.player.y;
        }
    }

    function toggleBuildMode() {
        gameState.mode = (gameState.mode === 'PLAY') ? 'BUILD' : 'PLAY';
        gameState.movingObj = null;
        gameState.isPlaced = false;
        document.getElementById('build-confirm').style.display = 'none';
    }

    function triggerAction() {
        const p = gameState.player;
        if (p.holding > 0) {
            gameState.deliveries.push({ x: p.x, y: p.y, qty: p.holding });
            p.holding = 0;
        } else {
            gameState.deliveries.forEach((d, i) => {
                if (Math.hypot(p.x - d.x, p.y - d.y) < 60) {
                    p.holding = 5;
                    gameState.deliveries.splice(i, 1);
                }
            });
        }
    }

    function confirmPlacement() {
        if (gameState.movingObj) {
            gameState.movingObj.gridX = gameState.tempPos.gX;
            gameState.movingObj.gridY = gameState.tempPos.gY;
        }
        gameState.movingObj = null;
        gameState.isPlaced = false;
        document.getElementById('build-confirm').style.display = 'none';
    }

    function cancelPlacement() {
        gameState.movingObj = null;
        gameState.isPlaced = false;
        document.getElementById('build-confirm').style.display = 'none';
    }

    function update() {
        const p = gameState.player;
        p.x += (p.tX - p.x) * 0.15;
        p.y += (p.tY - p.y) * 0.15;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Define shopWidth inside draw to prevent reference errors
        const shopWidth = COLS * TILE;

        // Shop Floor
        ctx.fillStyle = "#222";
        ctx.fillRect(offX, offY, shopWidth, ROWS * TILE);

        // Grid
        ctx.strokeStyle = "#333";
        for(let i=0; i<=COLS; i++) {
            ctx.beginPath(); ctx.moveTo(offX + i*TILE, offY); ctx.lineTo(offX + i*TILE, offY + ROWS*TILE); ctx.stroke();
        }
        for(let j=0; j<=ROWS; j++) {
            ctx.beginPath(); ctx.moveTo(offX, offY + j*TILE); ctx.lineTo(offX + shopWidth, offY + j*TILE); ctx.stroke();
        }

        // Furniture
        const c = gameState.counter;
        ctx.fillStyle = c.color;
        ctx.fillRect(offX + c.gridX * TILE, offY + c.gridY * TILE, c.w * TILE, c.h * TILE);

        gameState.shelves.forEach(s => {
            ctx.fillStyle = s.color;
            ctx.fillRect(offX + s.gridX * TILE, offY + s.gridY * TILE, s.w * TILE, s.h * TILE);
        });

        // Deliveries
        ctx.fillStyle = "#fb8c00";
        gameState.deliveries.forEach(d => {
            ctx.fillRect(d.x - 10, d.y - 10, 20, 20);
        });

        // Player
        ctx.fillStyle = "#2196F3";
        ctx.beginPath(); ctx.arc(gameState.player.x, gameState.player.y, 15, 0, Math.PI*2); ctx.fill();

        document.getElementById('money-display').innerText = `Cash: $${gameState.money}`;
    }

    function handleInput(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const mx = clientX - rect.left;
        const my = clientY - rect.top;
        
        const gX = Math.floor((mx - offX) / TILE);
        const gY = Math.floor((my - offY) / TILE);

        if (gameState.mode === 'BUILD') {
            if (!gameState.movingObj) {
                // Check Counter selection
                if (gX >= gameState.counter.gridX && gX < gameState.counter.gridX + gameState.counter.w &&
                    gY >= gameState.counter.gridY && gY < gameState.counter.gridY + gameState.counter.h) {
                    gameState.movingObj = gameState.counter;
                    return; // Stop here!
                }
                // Check Shelves selection
                for (let s of gameState.shelves) {
                    if (gX >= s.gridX && gX < s.gridX + s.w && gY >= s.gridY && gY < s.gridY + s.h) {
                        gameState.movingObj = s;
                        return; // Stop here!
                    }
                }
            } else if (!gameState.isPlaced) {
                gameState.tempPos = { gX, gY };
                gameState.isPlaced = true;
                const ui = document.getElementById('build-confirm');
                ui.style.display = 'flex';
                ui.style.left = clientX + 'px';
                ui.style.top = (clientY - 60) + 'px';
                return;
            }
        }
        
        gameState.player.tX = mx;
        gameState.player.tY = my;
    }

    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0) handleInput(e.clientX, e.clientY);
        if (e.button === 2) triggerAction();
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleInput(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    window.addEventListener('resize', resize);
    window.oncontextmenu = (e) => e.preventDefault();

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resize();
    loop();
</script>
</body>
</html>
